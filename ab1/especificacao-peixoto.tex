\documentclass[
  % -- opções da classe memoir --
  12pt,				% tamanho da fonte
  % openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
  oneside,			% para impressão somente frente. Oposto a twoside (frente e verso)
  a4paper,			% tamanho do papel. 
  % -- opções da classe abntex2 --
  %chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
  %section=TITLE,		% títulos de seções convertidos em letras maiúsculas
  %subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
  %subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
  % -- opções do pacote babel --
  english,			% idioma adicional para hifenização
  french,				% idioma adicional para hifenização
  spanish,			% idioma adicional para hifenização
  brazil,				% o último idioma é o principal do documento
]{abntex2}


% ---
% PACOTES
% ---

% ---
% Pacotes fundamentais 
% ---
\usepackage{cmap}				% Mapear caracteres especiais no PDF
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{float}

% ---

% ---
% Pacotes adicionais, usados no anexo do modelo de folha de identificação
% ---
\usepackage{multicol}
\usepackage{array}
\usepackage{tabu}
\usepackage{multirow}
\usepackage{listings}
\usepackage{hyperref}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codered}{rgb}{0.960,0,0.054}
\definecolor{codeblue}{rgb}{0, 0.141, 0.960}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codepurple},
    stringstyle=\color{codemagenta},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle,frame=tb}
\lstset{
  morekeywords={defun, int, defint, echo, return, deffloat, defbool,
    defchar, if, else, set, string, defstring, read, while, for,
    break, continue, nil}
}
\renewcommand{\lstlistingname}{Código}% Listing -> Algorithm
% ---
	
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}	% Citações padrão ABNT
\usepackage{tabularx}


% --- 
% CONFIGURAÇÕES DE PACOTES
% --- 

% ---
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
  \ifcase #1 %
  Nenhuma citação no texto.%
  \or
  Citado na página #2.%
  \else
  Citado #1 vezes nas páginas #2.%
  \fi}%
% ---

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{Especificação da linguagem de programação LisC}
\autor{Lucas Peixoto de Almeida Cavalcante}
\local{Brasil}
\data{Maceió/Al\\Julho de 2019}
\instituicao{%
  Universidade Federal de Alagoas
  \par
  Instituto de Computação
}
\tipotrabalho{Relatório técnico}
\preambulo{Especificação da linguagem de programação LisC, definida
  pelo aluno, para a disciplina de Compiladores, correspondente à
  parte da avaliação da AB1 do semestre de 2019.2, sob orientação do
  \textbf{Prof. Alcino Dall Igna Jr.}}
% ---

% ---
% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
  %pagebackref=true,
  pdftitle={\@title}, 
  pdfauthor={\@author},
  pdfsubject={\imprimirpreambulo},
  pdfcreator={LaTeX with abnTeX2},
  pdfkeywords={abnt}{latex}{abntex}{abntex2}{relatório técnico}, 
  colorlinks=true,       		% false: boxed links; true: colored links
  linkcolor=blue,          	% color of internal links
  citecolor=blue,        		% color of links to bibliography
  filecolor=magenta,      		% color of file links
  urlcolor=blue,
  bookmarksdepth=4
}
\makeatother
% --- 

% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% ---
% compila o indice
% ---
\makeindex
% ---

% ----
% Início do documento
% ----
\begin{document}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
\imprimirfolhaderosto*
% ---

% ---
% inserir o sumario
% ---

\tableofcontents*

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS  (necessário para incluir número nas páginas)
% ----------------------------------------------------------
\textual
\chapter{Introdução}
\label{cha:intro}
Esse documento tem como objetivo especificar as características da
linguagem de programação LisC. Ao longo dos capítulos subsequentes
entenderemos as particularidades dessa linguagem no que diz respeito
ao escopo dela, aos nomes, tipos e estrutura de dados, atribuições,
expressões e mais.

A especificação dessa linguagem servirá de base para a implementação
dos analisadore léxico e sintático, que serão desenvolvidas
posteriormente no decorrer da disciplina. Ambos os analisadores serão
implementados na linguagem de programação C. Ao fim deste documento
também existirá uma seção reservada para a especificação dos tokens da
linguagem.


\chapter{Estrutura do programa}
\label{cha:estrutura-do-programa}
Esse capítulo tem como objetivo especificar como se da a estrutura
geral de um programa em LisC. O início de um programa em LisC ocorre
com a definição de uma função chamada \textbf{begin}, que retorna um
\emph{inteiro}. Sem essa função a compilação do programa da erro. Um
exemplo de código de uma função \textbf{begin} pode ser visto no
\textbf{código \ref{code:begin}}.
Em LisC temos que as funções só podem ser declaradas e definidas num
escopo global, ou seja, não é permitido que uma função seja criada
dentro de outra função. Note que nesse exemplo de código podemos
observar que os blocos da linguagem são delimitados com a presença
de chaves(\{\}).

\begin{lstlisting}[label={code:begin},caption=Código
    exemplo de uma função begin.]
  defun start ()(int) {
    defint a 5;
    echo ("a = \%d") (a);
    return 0;
  }
\end{lstlisting}

A presença de abre e fecha chaves define a presença de um
novo escopo dentro da linguagem, variáveis que são criadas dentro
desse escopo são consideradas variáveis locais, já as variáveis
criadas fora de um escopo são chamadas de variáveis globais. As
variáveis globais são visíveis dentro de qualquer escopo, já as locais
só são vistas dentro do escopo ao qual ela foi criada, além disso a
linguagem admite \textbf{mascaramento} de variáveis. Parâmetros de
funções tem como escopo todo o bloco da função.

Também no código \ref{code:begin} podemos ver o primeiro exemplo
da criação de uma variável. A variável criada foi uma variável do
tipo inteiro. A declaração de uma variável se dá a partir da junção da
palavra \textbf{def} com o tipo da variável em questão, como nesse
caso
tivemos uma variável inteira, a definiçao da mesma foi feita
utilizando
a palavra reservada \textbf{defint}. Note que a vinculação de tipos de
dados às variáveis é estática, sendo assim o tipo é definido
explicitamente pelo programador no momento da declaração da variável.

Toda instrução da linguagem LisC deve ser terminada com o caractere
\textbf{";"}. E os comentários da linguagem são apenas comentários de
linha e são feitos a partir dos caracteres \textbf{"//"}. As
instruções da linguagem devem estar dentro de escopos de funções. No
escopo global só é permitido a declaração ou definição de funções e
variáveis.

\chapter{Identificadores}
\label{cha:identificadores}
Os identificadores em LisC são declarados como na maioria das outras linguagens,
iniciando com uma letra e seguido ou não de uma ou mais letras e
dígitos. Em LisC os identificadores também são sensíveis à capitalização, além
de não possuir limite de caracteres. A definição de letra e dígito
pode ser dada como segue:

\begin{description}
\item [Letra]:pertence ao conjunto de caracteres $[A-Z]\cup[a-z]$
\item [Dígito]:pertence ao conjunto de caracteres $[0-9]$
\end{description}

Dessa forma temos que os identificadores em LisC podem ser representados pelo
autômato cuja expressão regular é dada por
\textbf{\lstinline[]{[A-Za-z]([A-Za-z]|[0-9])*}}. Note que os
identificadores não podem fazer parte do conjunto das palavras
reservadas da linguagem. No \textbf{capítulo}
\ref{cha:palavras-reservadas} vamos saber quais são as palavras
reservadas da linguagem.

\chapter{Palavras-reservadas}
\label{cha:palavras-reservadas}
As palavras reservadas da linguagem podem ser vistas na tabela
\ref{tab:palavras-reservadas}.

\begin{table}[H]
  \centering
  \caption{Tabela contendo todas as palavras reservadas da linguagem.}
  \label{tab:palavras-reservadas}
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    defun & defint & defchar & deffloat & defbool \\ \hline
    if&  else& int &  for& while \\ \hline
    echo&  return&  break&  continue& nil \\ \hline
    true&  false& char& float & bool\\ \hline
    string&  defstring& &  &\\ \hline
  \end{tabular}
\end{table}

\chapter{Tipos de dados}
\label{cha:tipos-de-dados}

A linguagem LisC possui os seguintes tipos de dados: inteiro, ponto
flutuante, caractere e booleano. E possui as seguintes estruturas de
dados: cadeia de caracteres e arranjos unidimensionais. No capítulo
\ref{cha:atribuicoes-expressoes-operadores} veremos com mais detalhes
como atribuir valor as variáveis que serão vistas nesse capítulo, o
que envolve os tipos de operação.

\section{Tipos de dados primitivos}
\label{sec:tipos-de-dados-primitivos}

Nessa seção iremos falar a respeito de cada um dos quatro tipos de
dados primitivos existentes.

\subsection{Inteiro}
\label{subsec:inteiro}
As variáveis do tipo inteiro representam os números inteiros. Podemos
ver no \textbf{código} \ref{code:int} como é feita a declaração de uma
variável desse tipo. A palavra reservada que representa esse tipo de
variável é a palavra \textbf{int}.

\begin{lstlisting}[label=code:int,caption=Declaração de uma variável inteira]
  defint <nome>;
\end{lstlisting}


As constantes literais de uma variável inteira estão contidas no
intervalo de
\\
\{-2.147.483.648, +2.147.483.647\}. Temos como exemplo
os seguintes valores: [-2, -40, 0, 55, 12].

\subsection{Ponto flutuante}
\label{subsec:ponto-flutuante}
As variáveis do tipo ponto flutuante representam os números
reais. Podemos ver no \textbf{código} \ref{code:float} como
é feita a declaração de uma variável desse tipo. A palavra reservada
que representa esse tipo de variável é a palavra \textbf{float}.

\begin{lstlisting}[label=code:float,caption=Declaração de uma variável
  tipo ponto flutuante.]
  deffloat <nome>;
\end{lstlisting}

As constantes literais de uma variável float estão contidas no
intervalo de
\\
\{-3.4e+38, 3.4e+38\}. Temos como exemplo
os seguintes valores: [-2.2, -40.5, 0, 55.0, 12.1].

\subsection{Booleano}
\label{subsec:booleano}
p
As variáveis do tipo booleano representam apenas dois
valores: verdadeiro ou falso. Podemos ver no \textbf{código}
\ref{code:booleano} como é feita a declaração de uma variável desse
tipo. A palavra reservada que representa esse tipo de variável é a palavra \textbf{bool}.

\begin{lstlisting}[label=code:booleano,caption=Declaração de uma variável booleana]
  defbool <nome>;
\end{lstlisting}


As contantes literais booleanas podem ser somente: \textbf{true} ou
\textbf{false}. Desse modo não existe um intervalo associado a esse
tipo de variável. Em LisC qualquer valor diferente de zero é
considerado verdadeiro e qualquer valor igual a zero é considerado
falso.

\subsection{Caractere}
\label{subsec:caractere}

As variáveis do tipo caractere representam os caracteres
alfanuméricos da tabela \textbf{ASCII}. Podemos ver no \textbf{código}
\ref{code:char} como é feita a declaração de uma variável desse
tipo. A palavra reservada que representa esse tipo de variável é a palavra \textbf{char}.

\begin{lstlisting}[label=code:char,caption=Declaração de uma variável caractere]
  defchar <nome>;
\end{lstlisting}

As contantes literais do tipo de variável caractere estão contidas no
pintervalo de [0, 127]. Temos como exemplo os seguintes valores: "a",
"b", "c".

\section{Estrutura de dados}
\label{sec:estrutura-de-dados}

Essa seção irá tratar dos tipos de dados que representam estruturas de
dados dentro da linguagem.

\subsection{Arranjos unidimensionais}
\label{subsec:arranjos-unidimensionais}

As variáveis do tipo arranjos unidimensionais podem ser de qualquer um
dos tipos primitivos já apresentados na \textbf{seção}
\ref{sec:tipos-de-dados-primitivos}. Esse tipo de variável é muito
utilizada para guardar uma quantidade de elementos de uma variável do mesmo
tipo. Note que a declaração é basicamente a mesma da declaração das
variáveis primitivas, a única diferença é a existência de colchetes
para definir qual será a quantidade exata dos elementos a serem
guardados. Perceba, portanto, que a quantidade de elementos é estática
e definida em tempo de compilação, de modo que o tamanho não pode ser
alterado após ter sido declarada e/ou definida. Temos no
\textbf{código} \ref{code:arranjos-unidimensionais} um exemplo da
declaração desse tipo de variável para cada um dos tipos primitivos.

\begin{lstlisting}[label=code:arranjos-unidimensionais,caption=Declaração
    de uma variável do tipo arranjo unidimensional.]
  defint numeros[5];
  defchar letras[10];
  defbool binarios[15];
  deffloat taxas[4];
\end{lstlisting}

As constantes literais desse tipo de variável não possuem um intervalo
de valores, visto que esse tipo de análise não faz muito
sentido. Exemplos desse tipo de variável podem ser: [1,2,3],
[true,false,true,false], [2.3, 1.6, -1.2].

O limite inferior de um arranjo unidimensional é 0, e o limite
superior é dado pelo tamanho - 1. Desse modo, o acesso a um elemento
específico dentro do arranjo pode ser feito a partir do
\textbf{código} \ref{code:acesso}.

\begin{lstlisting}[label=code:acesso,caption=Acessando elemento dentro
    de um arranjo unidimensional]
  defint numeros[5] {1,2,3,4,5}
  echo ("acessando indice \%d do arranjo numeros, valor: \%d") (2, numeros[1]) 
\end{lstlisting}


\subsection{Cadeia de caractere}
\label{subsec:cadeia-de-caractere}

As variáveis do tipo cadeia de caractere são basicamente um arranjo
unidimensional de uma variável primitiva do tipo \emph{char}. Esse
tipo de estrutura também é conhecido como \emph{string}. Temos no
\textbf{código} \ref{code:string} um exemplo da declaração de uma
variável do tipo cadeia de caractere com o tamanho definido e outra
com o tamanho sendo calculado a partir do valor associado a variável
no momento da definição.

\begin{lstlisting}[label=code:string,caption=Declaração de variáveis
    do tipo cadeia de caractere.]
  defstring palavra[10];
  defstring texto[] = "Saudosa maloca";
\end{lstlisting}

Note que na variável \emph{texto} o tamanho alocado para ela foi de
15 caracteres, sendo 14 para o texto em sí(\emph{Saudosa maloca}) e
mais um para marcar o fim da string, que seria o caracter "\textbackslash0". Para
strings, o caracter considerado nulo é o caracter "\textbackslash0" e geralmente
nas linguagens é utilizado para marcar o fim de uma string.

As formas de acesso a caracteres específicos de uma cadeia de
caracteres é feito da mesma forma que em arranjos unidimensionais.


\section{Equivalência de tipos}
\label{sec:equivalencia-de-tipos}

\subsection{Coerções admitidas}
\label{subsec:coercoes-admitidas}

Os tipos de coerções admitidas na linguagem de programação LisC são
relacionadas apenas as variáveis do tipo primitiva. As coerções
possíveis podem ser visualizadas na \textbf{tabela}
\ref{tab:coercoes}. A linguagem não tem nenhuma forma explícita de
conversão de tipos.

\begin{table}[H]
  \centering
  \caption{Coerções admitidas em LisC}
  \label{tab:coercoes}
  \begin{tabular}{|l|l|}
    \hline
    De & Para \\ \hline
    Inteiro & String, Ponto flutuante, Caracter, Booleano \\ 
    Ponto flutuante & String, Inteiro \\     
    Booleano & String \\ 
    Caracter & String \\     \hline
  \end{tabular}
\end{table}

\subsection{Verificação de tipo}
\label{subsec:verificacao-de-tipo}

Para garantir que os tipos em LisC sejam respeitados, é feita uma
verificação em tempo de compilação. Essa verificação é feita tanto em
operações entre variáveis, para garantir que os tipos são compatíveis,
como na verificação dos tipos de parâmetros de funçoes.

\subsection{Tipagem}
\label{subsec:tipagem}

A linguagem LisC é fortemente tipada.

\section{Constantes com nome}
\label{sec:constantes-com-nome}

A linguagem LisC não admite constantes com nomes.

\chapter{Atribuições e expressões}
\label{cha:atribuicoes-e-expressoes}

Nesse capítulo iremos tratar a respeito das atribuições e das
expressões presentes em LisC. Será visto como que as atribuições são
feitas e entenderemos um pouco melhor os tipos de expressões presentes
na linguagem, sua precedência, quais tipos de variáveis estão
associados a operação e etc. Primeiro falaremos sobre as atribuições
na \textbf{seção} \ref{sec:atribuicoes} e em seguida veremos a respeito das
expressões na \textbf{seção} \ref{sec:expressoes}.

\section{Atribuições}
\label{sec:atribuicoes}

As atribuições são responsáveis por associar algum valor a uma
variável. No \textbf{código} \ref{code:atribuicoes} podemos ver alguns
exemplos de atribuições em LisC.

\begin{lstlisting}[label=code:atribuicoes,caption=Exemplos de
  atribuições.]
  defint age 15;
  set age ((age + 15) - 20);
  deffloat lado, area_quadrado, area_triangulo;
  set lado 5;
  set area_quadrado (lado * lado);
  set area_triangulo (area_quadrado - 1);
  defbool x (area_quadrado > area_triangulo);
  defbool res !x;
\end{lstlisting}

Note que nesses exemplos as atribuições foram feitas de várias
formas. No momento da declaração de uma variável é possível definir de
imediato um valor inicial. Após a definição da variável, qualquer
atribuição é feita a partir da palavra reservada \emph{set}.

Uma variável pode ter seu valor alterado a partir de uma constante
literal, de uma expressão aritmética, relacional ou lógica, a
depender do tipo da variável, retorno de função ou até mesmo de uma
concatenação de cadeia de caracteres, caso a variável seja do tipo
cadeia de caracteres.

\section{Expressões}
\label{sec:expressoes}

Existem cinco tipos diferentes de expressões em LisC: aritméticas,
relacionais, lógicas, concatenação e formatação. As seções a seguir
vão especificar as características de cada uma das expressões
disponíveis. 

\subsection{Aritmética}
\label{subsec:aritmeticas}

As expressões aritméticas estão relacionadas apenas as variáveis do tipo numéricas,
ou seja, \emph{int} e \emph{float}. Em LisC temos somente os
operadores abaixo, que estão listados de cima para baixo, do maior
para o menor na ordem de precedência.

\begin{description}
\item [Negativo]: símbolo "-", é um operador unário.
\item [Divisão e multiplicação]: símbolo "/" e "*", ambos são
  operadores binários.
\item [Soma e subtração]: símbolo "+" e "-", ambos são operadores binários.
\end{description}

Em expressões aritméticas temos que o operando mais a esquerda é
chamado de operando alvo, ou seja, é ele quem vai ditar qual será o
tipo final do resultado da operação. Sendo assim, caso o operando mais
a esquerda seja do tipo \emph{int}, mesmo que o segundo operando seja
do tipo \emph{float} o resultado da operação será um valor do tipo \emph{int}.

\subsection{Relacional}
\label{subsec:relacionais}

As expressões relacionais tem como resultado um valor sempre do tipo
booleano. Podemos ver abaixo os tipos de operadores relacionais
disponíveis.

\begin{description}
\item [Igualdade]: símbolo é o "=="
\item [Desigualdade]: símbolo é o "!="
\item [Menor que]: símbolo é o "<"
\item [Maior que]: símbolo é o ">"
\item [Menor ou igual que]: símbolo é o "<="
\item [Maior ou igual que]: símbolo é o ">="
\end{description}

Para tipos booleanos, como é um tipo de variável que só tem dois
valores, só faz sentido pensar nos operadores de igualdade e
desigualdade. Contudo, com relação aos outros tipos de variáveis
podemos criar uma expressão relacional com qualquer um dos operadores
disponíveis.

Nas operações aritméticas tinhamos que mesmo que os
operandos envolvidos não fossem do mesmo tipo, existia uma coerção
automática para concluir o resultado da operação. Contudo, para
expressões relacionais esse tipo de coerção não existe e resulta em
erros. O motivo é trivial de perceber, não faz sentido relacionar duas
variáveis de tipos diferentes.

\subsection{Lógica}
\label{subsec:logicas}

As expressões lógicas são utilizadas apenas quando os seus operandos
são booleanos. Podemos ver abaixo os tipos de operandos lógicos
disponíveis.

\begin{description}
\item [Negação]: símbolo "!", unário
\item [Conjunção]: símbolo "\&\&", binário
\item [Disjunção]: símbolo "||", binário
\end{description}

Os operadores foram dispostos em ordem de precedência, do maior para o
menor.

\subsection{Concatenaçao}
\label{subsec:concatenacao}

As operações de concatenação tem como resultado sempre um valor do
tipo string. Quando a concatenação é feita a partir de um caracter ou
uma cadeia de caractere a operação é feita normalmente, já que como
uma cadeia de caractere é um conjunto de caracteres, a operação não
precisa de conversão de tipo. Contudo, quando a operação é feita com a
presença de valores numéricos ou booleanos, estes são convertidos para
string antes da operação ser efetuada.

Temos no \textbf{código} \ref{code:concat} exemplos de código
envolvendo concatenação em LisC, onde o operador de concatenação é o "<<".

\begin{lstlisting}[label=code:concat,caption=Exemplo de expressões de concatenação]
  defint idade 5;
  deffloat tamanho 30.0;
  defstring nome "Asnestro"
  defstring frase ("Tenho um cachorro chamado " << nome << ", ele tem "
  << idade << " anos e mede " << tamanho << "cm");
  echo frase;
  \\ a saida desse codigo e "Tenho um cachorro chamado Asnestro, ele
  tem 5 anos e mede 30.0cm"
\end{lstlisting}

\subsection{Formatação}
\label{subsec:formatacao}
Os operadores de formatação são muito utilizados na apresentação do
valor de variáveis. Esse operador é utilizado para variáveis do tipo
\emph{int} e \emph{float}. Quando se trata de um inteiro fazemos a
formatação do número de campos desse inteiro, já quando se trata de um
ponto flutuante fazemos a formatação do número de casas
decimais. Podemos ver no \textbf{código} \ref{code:formatacao}
exemplos do uso do operador de formatação.

\begin{lstlisting}[label=code:formatacao,caption=Exemplo do uso do
  operador de formatação]
  // <variavel>%<numero de campos>
  // <variavel>%%<numero de casas decimais>
  defint time 1551;
  defint hora time\%2;
  deffloat pi 3.14159265359;
  deffloat pi-formatado pi%%2;
\end{lstlisting}

Note que a variável \emph{hora} é uma variável inteira e a variável
\emph{pi-formatado} é uma variável de ponto flutuante. O resultado de uma
operação de formatação tem sempre como resultado uma variável do tipo
do elemento a esquerda que foi utilizado



\section{Ordem de precedência e associatividade geral}
\label{sec:order-de-precedencia-e-associatividade-geral}

Visto que todos os tipos de operadores já foram apresentados, se faz
necessário definir qual a precedência entre operdores de tipos de
expressões diferentes. A \textbf{tabela} \ref{tab:precedencia-geral}
nos mostra a ordem de precedência entre todos os operadores da
linguagem.

Além disso, existe a possibilidade de alterar a ordem de precedência
no meio do operação por meio dos parênteses \emph{()}. Caso uma
expressão seja colocada entre parênteses, esta deve ser executada
primeiro do que as mais externas ao parênteses, ou seja, temos um
acréscimo no nível de precedência da operação.

\begin{table}[H]
  \centering
  \begin{tabularx}{16cm}{|X|X|X|}
    \hline
    Ordem de precedência                   & Operadores & Símbolos \\ \hline
    \multirow{8}{*}{Do maior para o menor} & Negativo, Negação &  -,!\\ \cline{2-3} 
                                           & Multiplicação, Divisão & *,/ \\ \cline{2-3} 
                                           & Soma, Subtração & +,-   \\
    \cline{2-3}
                                           & Concatenação & <<   \\ \cline{2-3}
                                           & Igualdade, Desigualdade,
                                             Maior que, Menor que, Maior
                                             ou igual que, Menor ou igual
                                             que & ==, !=, >, <, >=, <=   \\ \cline{2-3}
                                           & Conjunção, Disjunção & \&\&,||   \\ \hline
  \end{tabularx}
  \caption{Ordem de precedência geral}
  \label{tab:precedencia-geral}
\end{table}

Caso existam operadores adjascentes com o mesmo nível de precedência,
a expressão será resolvida da esquerda para a direita. Contudo, caso
os operadores em questão sejam os operadores negativo ou de negação,
temos a associatividade da direita para a esquerda.


\chapter{Instruções}
\label{cha:instrucoes}

Nesse capítulo vamos discutir um pouco mais sobre algumas instruções
importantes em LisC, sendo elas as instruções de Entrada, Saída,
controles lógicos e estruturas de repetição. Algumas dessas instruções
já foram apresentadas ao longo, mas agora serão definidas.

\section{Entrada}
\label{sec:entrada}

Esse tipo de instrução aparecerá agora pela primeira vez nesse
documento. As instruções de leitura do \emph{stdin} são feitas a
partir da palavra reservada \emph{read}. Podemos ver um exemplo desse
tipo de instrução no \textbf{código} \ref{code:read}.

\begin{lstlisting}[label=code:read,caption=Exemplo de código da
  instrução read.]
  // read <variaveis que deve ser inseridas>
  defint a, b, c;
  read (a, b, c);
  // a instrucao acima espera do stdin a entrada de 3 valores
  // que serao associados as variaveis "a", "b" e "c".
\end{lstlisting}
A instrução \emph{read} da a possibilidade de receber mais de um valor
de entrada por instrução.

\section{Saída}
\label{sec:saida}

A instrução de escrita no \emph{stdout} já foi vista algumas vezes
nesse documento, como no \textbf{código} \ref{code:concat}, por
exemplo. Podemos ver no \textbf{código} \ref{code:echo} como a
instrução pode ser utilizada.

\begin{lstlisting}[label=code:echo,caption=Exemplo de código da
  instrução echo]
  // echo <texto formatado> <variaveis a serem substituidas no texto
  formatado>
  defint a 5;
  defint b 6;
  
  echo ("a = " << a << "\nb = %d") (b);
\end{lstlisting}
A instruçao \emph{echo} já adiciona automaticamente um
\emph{\textbackslash n} ao
término do texto formatado.

\section{Controles lógicos}
\label{sec:controles-logicos}

O controle lógico que a linguagem LisC fornece é o controle via as
palavras reservadas \emph{if} e \emph{else}. O \emph{else} só pode
existir caso, previamente, uma instrução \emph{if} tenha sido
definida. Dessa forma, todo \emph{else} está associado a um único
\emph{if}, e um \emph{if} pode ou não estar associado a um
\emph{else}. Podemos ver no \textbf{código} \ref{code:ifelse} um
exemplo do uso desses tipos de instruções. Notem que todo \emph{if} é
seguido de uma expressão lógica entre parênteses, que será testada
para ver se o código entrará no bloco do \emph{if} ou do \emph{else}.

\begin{lstlisting}[label=code:ifelse,caption=Exemplo do uso de
  instruções de controles lógicos]
  defbool cond true;
  defbool cond2 false;

  if (cond) {
    echo "Cond e verdadeira";
  }
  else {
    echo "Cond e falsa";    
  }

  if (cond2) {
    echo "Cond2 e verdadeira";        
  }
  else {
    echo "Cond2 e falsa";        
  }

  // a saida desse codigo seria "cond e verdadeira" no primeiro if
  // "cond2 e falsa" no segundo if.
  
\end{lstlisting}

Dentro de uma estrutura de repetição podem ser usadas quaisquer
instruções que poderiam ser utilizadas num escopo de função, ou seja,
podem existir outras estruturas de decisão, chamadas de funções,
definição de variáveis, estruturas de repetição e etc.

\section{Estruturas de repetição}
\label{sec:estruturas-de-repeticao}

Existem dois tipos de estrutura de repetição em LisC, a primeira é a
estrutura de repetição baseada num controle lógico, já a segunda é a
estrutura de repetição baseada num contador. A primeira estrutura será
executada até quando a expressão lógica for verdadeira. A segnda
estrutura será executada até quando a variável controlada não atingir
o valor final dela.

Podemos ver nos \textbf{códigos} \ref{code:while} e \ref{code:for} 
exemplos dessas duas estruturas de repetição, que são definidas
através das palavras reservadas \emph{while} e \emph{for}, respectivamente.

\begin{lstlisting}[label=code:while,caption=Exemplo da estrutura de
  repetição while]
  // while (<expressao logica>) {<bloco de codigo>}
  defint a 1;

  while (a > 0) {
    read a;
  }

\end{lstlisting}

\begin{lstlisting}[label=code:for,caption=Exemplo da estrutura de
  repetição for]
  // for (<contador>, <valor inicial>, <valor final>) {<bloco de codigo>}
  defint count;

  for (count, 0, 10) {
    echo count;

    set count count+1;
  }
\end{lstlisting}

\subsection{Desvios incondicionais}
\label{subsec:desvios-incondicionais}

LisC fornece a possibilidade de efetuar desvios incondicionais dentro
de estruturas de repetição. Desse modo, caso o programador queira a
qualquer momento finalizar um laço de repetição, basta ele utilizar a
instrução \emph{break;}. De outro modo, caso o programador queira pular
a execução de um laço de repetição, fazendo com que se inicie
imediatamente a execução do laço novamente, se utiliza a instrução
\emph{continue;}. No \textbf{código} \ref{code:desvios-incondicionais}
podemos visualizar essas instruções atuando.

\begin{lstlisting}[label=code:desvios-incondicionais,caption=Exemplo
  de código de desvios incondicionais]
  defint count;

  for (count, 0, 20) {
    if (count < 10) {
      continue;
    }

    if (count == 17) {
      break;
    }

    echo count;
  }

  // esse codigo tras como saida
  // 11
  // 12
  // 13
  // 14
  // 15
  // 16
\end{lstlisting}

\chapter{Funções}
\label{cha:funcoes}

Já vimos no \textbf{código} \ref{code:begin} um exemplo da definição
de uma função. Segue no \textbf{código} \ref{code:fun} um exemplo mais
detalhado.

\begin{lstlisting}[label=code:fun,caption=Exemplo de definição de uma
  função]
  // Definicao de uma funcao:
  // defun <nome> (<parametros de entrada>)(<tipo de retorno>) {<bloco
    de codigo>}
  // Chamada de uma funcao:
  // <nome>(<parametros de entrada>)

  defint num 10;
  
  defun plus5(int a)(int) {
    return a + 5;
  }

  defun start ()(int) {
    echo plus5(num);

    return 0;
  }

  // saida desse codigo e:
  // 15
\end{lstlisting}

A linguagem não permite a definição de funções aninhadas. Note que o
retorno de uma função é determinado a partir da palavra reservada
\emph{return}

\section{Parâmetros das funções}
\label{sec:parametros-das-funções}

Com relação aos tipos que as funções podem ter em seus
parâmetros e em seu retorno, temos que as funções em LisC podem ter
tanto as entradas como as saídas de qualquer um dos tipos primitivos e
dos não primitivos(arranjos unidimensionais e cadeia de caracteres) da
linguagem já apresenados na \textbf{seção} \ref{cha:tipos-de-dados}. A
passagem de parâmetros para funções é feita somente por valor.

\section{Retorno das funções}
\label{sec:returno-das-funcoes}

Caso a função não tenha retorno, em sua definição os segundos parênteses
devem estar vazios, e nesse caso não é necessário o uso da palavra
reservada \emph{return} no bloco da função. Caso o programador deseje
explicitar o momento de retorno da função, se faz necessário que o
\emph{return} seja usado sem nenhum valor associado a ele, ou
seja, \emph{return;}.

\section{Funções como parâmetros}
\label{sec:funções-como-parametros}

Funções não podem ser passadas como parâmetros, não podem ser
sobrecarregadas e não podem ser genéricos.

\chapter{Programas exemplo}
\label{cha:programas-exemplo}

\section{Alô mundo}
\label{sec:alo-mundo}

\begin{lstlisting}[label=code:alo-mundo,caption=Programa Alô mundo]
  defun start()(int) {
    echo "Alo mundo";
    return 0;
  }
\end{lstlisting}

\section{Fibonacci}
\label{sec:fibonacci}

\begin{lstlisting}[label=code:fibonacci,caption=Programa Fibonacci]
  defun start()(int) {
    defint n;
    defint first 0;
    defint second 1;
    defint next;
    defint c;

    echo "Digite o numero de termos da sequencia";
    read (n);

    echo "Os primeiros %d termos de fibonacci sao:" (n);

    for (c, 0, n) {
      if (c <= 1) {
        set next c;
      }
      else {
        set next (first + second);
        set first second;
        set second next;
      }

      echo next;
      set c c+1;
    }
    return 0;
  }
\end{lstlisting}

\section{Shell sort}
\label{sec:shell-sort}

\begin{lstlisting}[label=code:shell-sort,caption=Programa do shell
  sort]
  defun shell_sort(int ar[], int n)(int) {
    defint gap, i;
    for (gap, n/2, 0) {
      for (i, gap, n) {
        defint temp ar[i];
        defint j;

        for (j, i, gap+1) {
          if (ar[j - gap] > temp) {
            break;
          }

          set ar[j] arr[j-gap];
          set j (j-gap);
        }

        set ar[j] temp;
        set i i+1;
      }

      set gap (gap/2);
    }
  }

  defun start()(int) {
    defint ar[] {12, 34, 54, 2, 3};
    defint i;
    defint n 5;

    shell_sort(ar, n);

    for(i, 0, n) {
      echo ar[i];
      set i i+1;
    }
  }

\end{lstlisting}


\chapter{Especificação dos tokens}
\label{cha:especificacao-dos-tokens}



% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual

%---------------------------------------------------------------------
% INDICE REMISSIVO
%---------------------------------------------------------------------

\printindex

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
