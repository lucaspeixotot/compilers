* Geração de código intermediário (Capítulo 5)
  A geração de código intermediário é a transformação da árvore de
  derivação em um segmento de código. Esse código pode, eventualmente,
  ser o código objeto final, mas, na maioria dos casos constitui-se
  num código intermediário, pois a tradução de código fonte para
  objeto em mais de um passo apresenta algumas vantagens, como:

  - Possibilita a otimização do código intermediário, de modo a
    obter-se o código objeto final mais eficiente;
  - simplifica a implementação do compilador, resolvendo,
    gradativamente, as dificuldades da passagem de código fonte para
    objeto, já que o código fonte pode ser visto como um texto
    condensado que "explode" em inúmeras instruções de baixo-nivel;
  - possibilita a tradução de código intermediário para diversas
    máquinas.

  A desvantagem de gerar código intermediário é que o computador
  requer um passo a mais. A tradução direta do código fonte para o
  objeto leva a uma compilação mais rápida.

  A única diferença entre o código intermediário e o código objeto
  final é que o código intermediário não especifica detalhes da
  máquina alvo.

** Linguagens intermediárias
   Os diferentes tipos de linguagem intermediária fazem parte de uma
   das três categorias abaixo.

   - representações gráficas: árvore e grafo de sintaxe;
   - notações pré e pós fixadas;
   - código de três-endereços, quadras e triplas.


** Árvore e grafo de sintaxe
   Um grafo de sintaxe além de incluir as simplificações da árvore de
   sintaxe, faz a fatoração das subexpressões comuns, eliminando-as,
   conforme a figura abaixo.

   [[/home/lucas/Pictures/2019-08-24-185929_441x254_scrot.png]]


*** Funções auxiliares
    *ptr* geraFolha(Categ categ, String lexema) {...}
    *ptr* geraNo(String opr, ptr node) {...}
    *ptr* geraNo(String opr, ptr node1, ptr node2) {...}

    Nota que dentro dessas funções se faz necessário verificar se os
    nós que estão querendo ser criados já existem, caso eles existam,
    basta retornar o ponteiro para esses nós já existentes.

*** Exemplo
    Exemplo de gramática com ações semânticas que geram um grafo de
    sintaxe.

    S = Ea '=' { s.ptr = geraNo(atr.lex, Ea.ptr); }
    Ea = Ea1 'opa' Ta { Ea.ptr = geraNo(opa.lex, Ea1.ptr, Ta.ptr); }
    Ea = Ta { Ea.ptr = Ta.ptr; }
    Ta = Ta1 'opm' Fa { Ta.ptr = geraNo(opm.lex, Ta1.ptr, Fa.ptr); }
    Ta = Fa { Ta.ptr = Fa.ptr; }
    Fa = '(' Ea ')' { Fa.ptr = Ea.ptr; }
    Fa = 'cten' { Fa.ptr = geraFolha('cten', cten.lex); }
    Fa = 'id' { Fa.ptr = geraFolha('id', id.lex); }

** Notações pré e pós-fixadas
   Notações pré e pós-fixadas podem ser generalizadas para operadores
   *n-ários*. Para a avaliação de expressões desse tipo, pode-se
   utilizar uma pilha e um processo que age do seguinte modo: lê a
   expressão da esquerda para a direita, empilhando cada operando até
   encontrar um operador. Encontrando um operador n-ário, aplica o
   operador aos n operandos do topo da pilha. Processamento semelhante
   pode ser aplicado para a avaliação de expressões pré-fixadas; nesse
   caso, a expressão é lida da direita para a esquerda.

[[/home/lucas/Pictures/2019-08-24-191620_444x151_scrot.png]]

*** Exemplo
    Exemplo de gramática com ações semânticas que geram uma notação
    pós-fixada.

    S = Ea '=' { print(Ea.cod); }
    Ea = Ea1 'opa' Ta { Ea.cod = Ea1.cod + Ta.cod + opa.lex; }
    Ea = Ta { Ea.cod = Ta.cod }
    Ta = Ta1 'opm' Fa { Ta.cod = Ta1.cod + Fa.cod + opm.lex; }
    Ta = Fa { Ta.cod = Fa.cod; }
    Fa = '(' Ea ')' { Fa.cod = Ea.cod; }
    Fa = 'cten' { Fa.cod = cten.lex; }
    Fa = 'id' { Fa.cod = id.lex; }
    
** Código de 3 endereços e quadras
   No código intermediário de 3 endereços, cada instrução faz
   referência a no máximo três variáveis(endereços de memória).
   O tipo de código intermediário que será utilizado na disciplina
   é o de quadras.

   A principal diferença entre os dois é a ocupação de memória, que
   nos dias de hoje não é um problema, devido ao fato de que a maioria
   dos dispositivos tem memória o suficiente para suportar quadras.

*** Funções auxiliares
    *String* geraTemp() {...}
    *String* geraRot() {...}
    *void* emiteRot() {...}
    *String* geraCod(String operador, String operando1, String operando2, String destino) {...}
    *String* geraCod(String operador, String operando, String destino) {...}
    *String* geraGt(String rotulo) {...}

*** Exemplo

    S = 'id' '=' Ea {
        S.cod = Ea.cod + geraCod('=', Ea.nome, id.lex);
    }
    Ea = Ea1 'opa' Ta { 
        Ea.nome = geraTemp();
        Ea.cod = Ea1.cod + Ta.cod + geraCod(opa.lex, Ea1.nome, Ta.nome,
        Ea.nome);
    }
    Ea = Ta { 
        Ea.nome = Ta.nome;
        Ea.cod = Ta.cod;
    }
    Ta = Ta1 'opm' Fa { 
        Ta.nome = geraTemp();
        Ta.cod = Ta1.code + Fa.cod + geraCod(opm.lex, Ta1.nome,
        Fa.nome, Ta.nome);
    }
    Ta = Fa {
        Ta.nome = Fa.nome;
        Ta.cod = Fa.cod;
    }
    Fa = '(' Ea ')' {
        Fa.nome = Ea.nome;
        Fa.cod = Ea.cod;
    }
    Fa = '-' Fa1 {
        Fa.nome = geraTemp();
        Fa.cod = Fa1.cod + geraCod("-u", Fa1.nome, Fa.nome);
    }
    Fa = 'cten' {
        Fa.nome = cten.lex;
        Fa.cod = "";
    }
    Fa = 'id' {
        Fa.nome = id.lex;
        Fa.cod = "";
    }

** Ações semânticas para construção de tabela de símbolos
   Esta seção apresenta esquemas de tradução que reconhecem
   declarações de variáveis e geram tabelas de símbolos. Inicialmente,
   é apresentado um esquema que gera tabelas de símbolos para
   programas monolíticos, isto é, formados por um único
   bloco. Posteriormente, esse esquema é estendido para permitir a
   geração de tabelas para programas bloco-estruturados com
   procedimentos aninhados.


** Expressões lógicas e comandos de controle   
   Expressões lógicas são usadas como expressões condicionais em
   comandos de controle e em comandos de atribuição lógica. Nesta
   seção, apresentaremos dois tipos de traduções para expressões
   lógicas.

   - Representação numérica: este método codifica numericamente as
     constantes true e false e avalia as expressões lógicas de forma
     numérica, ficando o resultado de avaliação numa variável
     temporária.
   - Representação por fluxo de controle: este método traduz
     expressões lógicas para instruções if e goto que desviam a
     execução do programa para pontos distintos, caso o resultado da
     avaliação seja true ou false.

*** Representação numérica
    Esquema de tradução para avaliação numérica de expressões
    lógicas. Note que o esquema de tradução abaixo gera código para
    expressões lógicas, supondo que as instruções geradas são
    armazenadas num vetor de quadruplas. A função geraCod, nesse caso,
    utiliza uma variável proxq para indicar o índice da próxima quadra
    disponível. Após gravar uma quadrupla, a função geraCod incrementa
    proxq.

    Eb = Eb1 'ou' Tb {
        NTerm Eb;
        Eb.nome = geraTemp();
        Eb.cod = Eb1.cod + Tb.cod + geraCod('or', Eb1.nome, Tb.nome,
        Eb.nome);
    }
    Eb = Tb { NTerm Eb = Tb; }
    Tb = Tb1 'e' Fb {
        NTerm tb;
        tb.nome = geraTemp();
        tb.cod = Tb1.cod + Fb.cod + geraCod('e', Tb1.nome, Fb.nome,
            tb.nome);
    }
    Tb = Fb { NTerm Tb = Fb; }
    Fb = 'nao' Fb1 {
        NTerm Fb;
        Fb.nome = geraTemp();
        Fb.cod = Fb1.cod + geraCod('nao', Fb1.cod, Fb.nome);
    }
    Fb = '(' Eb ')' { NTerm Fb = Eb; }
    Fb = Ea1 'opr' Ea2 {
        NTerm Fb;
        Fb.nome = geraTemp();
        Fb.cod = Ea1.cod + Ea2.cod + geraCod(opr.lex, Ea1.nome, Ea2.nome,
            geraRot(proxq+3)) + geraCod('=', '0', Fb.nome) +
            geraGT(geraRot(proxq+2)) + geraCod('=', '1', Fb.nome);
    }
    Fb = 'verd' { NTerm fb; fb.nome = geraTemp(); fb.cod =
        geraCod('=', '1', Fb.nome); 
    }
    Fb = 'falso' { NTerm fb; fb.nome = geraTemp(); fb.cod =
        geraCod('=', '0', Fb.nome);
    }


    Esquema de tradução para gramáticas com while
    
    Sent = 'enquanto' Eb 'faça' LSent 'fim' {
        String inicio = geraRot();
        String fim = geraRot();
        Sent.cod = emiteRot(inicio) + Eb.cod + geraCod('==', Eb.nome, '0',
        fim) + LSent.cod + geraGT(inicio) + emiteRot(fim);
    }


     

   
